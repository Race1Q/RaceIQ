import { describe, it, expect, vi, beforeEach } from 'vitest';
import { renderHook, waitFor } from '@testing-library/react';
import { useAiDriverFunFacts } from './useAiDriverFunFacts';
import * as api from '../lib/api';

vi.mock('../lib/api', () => ({
  buildApiUrl: vi.fn((path: string) => `http://localhost:3000${path}`),
}));

describe('useAiDriverFunFacts', () => {
  const mockFunFactsData = {
    driverId: 1,
    season: 2024,
    title: 'Max Verstappen - Fun Facts',
    facts: [
      'Youngest F1 driver ever at 17 years old',
      'Won first race at 18',
      'Three-time world champion',
    ],
    generatedAt: '2024-01-01T12:00:00Z',
    isFallback: false,
    aiAttribution: 'Generated by Gemini',
  };

  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('fetches fun facts successfully with driverId', async () => {
    global.fetch = vi.fn().mockResolvedValue({
      ok: true,
      json: async () => mockFunFactsData,
    }) as any;

    const { result } = renderHook(() => useAiDriverFunFacts(1));

    expect(result.current.loading).toBe(true);

    await waitFor(() => {
      expect(result.current.loading).toBe(false);
    });

    expect(result.current.data).toEqual(mockFunFactsData);
    expect(result.current.error).toBeNull();
  });

  it('does not fetch when driverId is undefined', async () => {
    global.fetch = vi.fn() as any;

    const { result } = renderHook(() => useAiDriverFunFacts(undefined));

    await waitFor(() => {
      expect(result.current.loading).toBe(false);
    });

    expect(global.fetch).not.toHaveBeenCalled();
    expect(result.current.data).toBeNull();
  });

  it('fetches with season parameter', async () => {
    global.fetch = vi.fn().mockResolvedValue({
      ok: true,
      json: async () => mockFunFactsData,
    }) as any;

    renderHook(() => useAiDriverFunFacts(1, 2024));

    await waitFor(() => {
      expect(global.fetch).toHaveBeenCalled();
    });

    const callUrl = (global.fetch as any).mock.calls[0][0];
    expect(callUrl).toContain('/api/ai/driver/1/fun-facts?season=2024');
  });

  it('fetches without season parameter', async () => {
    global.fetch = vi.fn().mockResolvedValue({
      ok: true,
      json: async () => mockFunFactsData,
    }) as any;

    renderHook(() => useAiDriverFunFacts(1));

    await waitFor(() => {
      expect(global.fetch).toHaveBeenCalled();
    });

    const callUrl = (global.fetch as any).mock.calls[0][0];
    expect(callUrl).toContain('/api/ai/driver/1/fun-facts');
    expect(callUrl).not.toContain('season=');
  });

  it('handles HTTP errors', async () => {
    global.fetch = vi.fn().mockResolvedValue({
      ok: false,
      status: 404,
      statusText: 'Not Found',
    }) as any;

    const { result } = renderHook(() => useAiDriverFunFacts(1));

    await waitFor(() => {
      expect(result.current.loading).toBe(false);
    });

    expect(result.current.error).not.toBeNull();
    expect(result.current.error?.message).toContain('Failed to fetch fun facts');
    expect(result.current.error?.message).toContain('404');
  });

  it('handles network errors', async () => {
    global.fetch = vi.fn().mockRejectedValue(new Error('Network error')) as any;

    const { result } = renderHook(() => useAiDriverFunFacts(1));

    await waitFor(() => {
      expect(result.current.loading).toBe(false);
    });

    expect(result.current.error).not.toBeNull();
    expect(result.current.error?.message).toBe('Network error');
  });

  it('re-fetches when driverId changes', async () => {
    global.fetch = vi.fn().mockResolvedValue({
      ok: true,
      json: async () => mockFunFactsData,
    }) as any;

    const { rerender } = renderHook(
      ({ driverId }) => useAiDriverFunFacts(driverId),
      { initialProps: { driverId: 1 } }
    );

    await waitFor(() => {
      expect(global.fetch).toHaveBeenCalledTimes(1);
    });

    rerender({ driverId: 2 });

    await waitFor(() => {
      expect(global.fetch).toHaveBeenCalledTimes(2);
    });

    const secondCallUrl = (global.fetch as any).mock.calls[1][0];
    expect(secondCallUrl).toContain('/api/ai/driver/2/fun-facts');
  });

  it('re-fetches when season changes', async () => {
    global.fetch = vi.fn().mockResolvedValue({
      ok: true,
      json: async () => mockFunFactsData,
    }) as any;

    const { rerender } = renderHook(
      ({ driverId, season }) => useAiDriverFunFacts(driverId, season),
      { initialProps: { driverId: 1, season: 2024 } }
    );

    await waitFor(() => {
      expect(global.fetch).toHaveBeenCalledTimes(1);
    });

    rerender({ driverId: 1, season: 2023 });

    await waitFor(() => {
      expect(global.fetch).toHaveBeenCalledTimes(2);
    });

    const secondCallUrl = (global.fetch as any).mock.calls[1][0];
    expect(secondCallUrl).toContain('season=2023');
  });

  it('handles non-Error exceptions', async () => {
    global.fetch = vi.fn().mockRejectedValue('String error') as any;

    const { result } = renderHook(() => useAiDriverFunFacts(1));

    await waitFor(() => {
      expect(result.current.loading).toBe(false);
    });

    expect(result.current.error).not.toBeNull();
    expect(result.current.error?.message).toBe('Unknown error occurred');
  });

  it('handles fallback fun facts', async () => {
    const fallbackData = { ...mockFunFactsData, isFallback: true };
    global.fetch = vi.fn().mockResolvedValue({
      ok: true,
      json: async () => fallbackData,
    }) as any;

    const { result } = renderHook(() => useAiDriverFunFacts(1));

    await waitFor(() => {
      expect(result.current.data?.isFallback).toBe(true);
    });
  });
});

