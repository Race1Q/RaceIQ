// frontend/src/components/compare/DriverPdfComparisonCard.tsx
import jsPDF from "jspdf";
import { getTeamColor } from "../../lib/teamColors";
import { getTeamLogo } from "../../lib/teamAssets";
import { loadImageAsDataURL } from "../../lib/pdfUtils";

interface DriverPdfData {
  id: string;
  fullName: string;
  teamName: string;
  championshipStanding: number | string | null;
  wins: number;
  podiums: number;
  points: number;
  imageUrl: string;
  teamColorToken: string;
  teamColorHex?: string;
}

interface DriverStats {
  wins: number;
  podiums: number;
  poles: number;
  fastestLaps: number;
  points: number;
  dnfs: number;
  sprintWins: number;
  sprintPodiums: number;
  races: number;
  recentForm: number;
}

interface DriverComparisonData {
  driver1: DriverPdfData;
  driver2: DriverPdfData;
  stats1: DriverStats;
  stats2: DriverStats;
  enabledMetrics: Record<string, boolean>;
  score: {
    d1: number | null;
    d2: number | null;
  };
}

export const DriverPdfComparisonCard = async (data: DriverComparisonData) => {
  const { driver1, driver2, stats1, stats2, enabledMetrics, score } = data;
  
  // Determine orientation based on number of selected metrics
  const enabledCountForLayout = Object.keys(enabledMetrics).filter((k) => (enabledMetrics as any)[k]).length;
  const usePortrait = enabledCountForLayout > 4; // switch to portrait when many rows
  const doc = new jsPDF(usePortrait ? "portrait" : "landscape", "mm", "a4");
  const pageWidth = doc.internal.pageSize.getWidth();
  const pageHeight = doc.internal.pageSize.getHeight();
  
  // Colors & theme
  const text = "#111827";
  const subtle = "#6b7280";
  const border = "#e5e7eb";
  const railW = 6;

  const d1Color = driver1.teamColorHex || getTeamColor(driver1.teamName) || "#0ea5e9";
  const d2Color = driver2.teamColorHex || getTeamColor(driver2.teamName) || "#ef4444";

  // Format numbers to remove trailing zeros
  const formatNumber = (value: number | string): string => {
    const num = typeof value === 'string' ? parseFloat(value) : value;
    if (typeof num !== 'number' || isNaN(num)) return String(value);
    // If it's an integer, return as is
    if (Number.isInteger(num)) return String(num);
    // Otherwise, format to remove trailing zeros
    return String(parseFloat(num.toFixed(10)));
  };

  // Safe text helper (no unsupported glyphs)
  const TXT = (t: string, x: number, y: number, opts: { size?: number; color?: string; align?: "left" | "center" | "right"; bold?: boolean } = {}) => {
    const { size = 11, color = text, align = "left", bold = false } = opts;
    doc.setTextColor(color);
    doc.setFont("helvetica", bold ? "bold" : "normal");
    doc.setFontSize(size);
    const xPos = align === "center" ? x : align === "right" ? x : x;
    doc.text(t, xPos, y, { align });
  };

  const rectF = (x: number, y: number, w: number, h: number, fill: string) => {
    doc.setFillColor(fill);
    doc.rect(x, y, w, h, "F");
  };

  const drawRails = () => {
    rectF(0, 26, railW, pageHeight - 26, d1Color);
    rectF(pageWidth - railW, 26, railW, pageHeight - 26, d2Color);
  };

  const drawFooter = () => {
    const footY = pageHeight - 10;
    const footText = "Generated by RaceIQ â€¢ raceiq.com";
    doc.setDrawColor(border);
    doc.line(marginX, footY - 6, pageWidth - marginX, footY - 6);
    TXT(footText, pageWidth / 2, footY, { size: 9, color: subtle, align: "center" });
  };

  // Header band
  rectF(0, 0, pageWidth, 26, "#0f172a");
  TXT("Driver Comparison", 10, 16, { size: 16, color: "#ffffff", bold: true });
  TXT("RaceIQ Analytics", pageWidth - 70, 12, { size: 10, color: "#cbd5e1", align: "left" });
  TXT(new Date().toLocaleDateString(), pageWidth - 70, 19, { size: 10, color: "#cbd5e1", align: "left" });

  // Side rails (team accents)
  drawRails();

  // Card layout
  const marginX = 16;
  const topY = 34;
  const cardW = (pageWidth - marginX * 2 - 20) / 2;
  const gap = 20;

  // Helper to detect image format from data URL
  const getImageFormat = (dataUrl: string): string => {
    if (!dataUrl) return 'PNG';
    if (dataUrl.includes('data:image/jpeg') || dataUrl.includes('data:image/jpg')) return 'JPEG';
    if (dataUrl.includes('data:image/png')) return 'PNG';
    if (dataUrl.includes('data:image/webp')) return 'WEBP';
    return 'PNG'; // Default fallback
  };

  // Load driver images with fallback to team logos
  let d1Image = null;
  let d1ImageFormat = 'PNG';
  let d2Image = null;
  let d2ImageFormat = 'PNG';
  
  // Try driver image first
  if (driver1.imageUrl) {
    try {
      const imageData = await loadImageAsDataURL(driver1.imageUrl);
      if (imageData && imageData.startsWith('data:image/') && imageData.length > 100) {
        d1Image = imageData;
        d1ImageFormat = getImageFormat(imageData);
      }
    } catch (error) {
      console.warn('Failed to load driver1 image, trying team logo:', error);
    }
  }
  
  // Fallback to team logo if driver image failed
  if (!d1Image) {
    try {
      const teamLogoUrl = getTeamLogo(driver1.teamName);
      if (teamLogoUrl) {
        const logoData = await loadImageAsDataURL(teamLogoUrl);
        if (logoData && logoData.startsWith('data:image/') && logoData.length > 100) {
          d1Image = logoData;
          d1ImageFormat = getImageFormat(logoData);
        }
      }
    } catch (error) {
      console.warn('Failed to load driver1 team logo:', error);
    }
  }
  
  // Try driver image first
  if (driver2.imageUrl) {
    try {
      const imageData = await loadImageAsDataURL(driver2.imageUrl);
      if (imageData && imageData.startsWith('data:image/') && imageData.length > 100) {
        d2Image = imageData;
        d2ImageFormat = getImageFormat(imageData);
      }
    } catch (error) {
      console.warn('Failed to load driver2 image, trying team logo:', error);
    }
  }
  
  // Fallback to team logo if driver image failed
  if (!d2Image) {
    try {
      const teamLogoUrl = getTeamLogo(driver2.teamName);
      if (teamLogoUrl) {
        const logoData = await loadImageAsDataURL(teamLogoUrl);
        if (logoData && logoData.startsWith('data:image/') && logoData.length > 100) {
          d2Image = logoData;
          d2ImageFormat = getImageFormat(logoData);
        }
      }
    } catch (error) {
      console.warn('Failed to load driver2 team logo:', error);
    }
  }

  // Driver cards: headers
  const leftX = marginX;
  const rightX = marginX + cardW + gap;

  const headerH = 34;

  // Initialize current Y position for content tracking
  let currentY = topY + headerH + 10;
  
  const ensureSpace = (needed: number) => {
    const availableSpace = pageHeight - 24 - currentY; // Reserve 24mm for footer
    if (availableSpace < needed) {
      // Add new page
      doc.addPage();
      currentY = 40; // Start position on new page
      
      // Redraw header and rails on new page
      rectF(0, 0, pageWidth, 26, "#0f172a");
      TXT("Driver Comparison", 10, 16, { size: 16, color: "#ffffff", bold: true });
      TXT("RaceIQ Analytics", pageWidth - 70, 12, { size: 10, color: "#cbd5e1", align: "left" });
      TXT(new Date().toLocaleDateString(), pageWidth - 70, 19, { size: 10, color: "#cbd5e1", align: "left" });
      drawRails();
    }
  };

  // Left header
  rectF(leftX, topY, cardW, headerH, "#f8fafc");
  doc.setDrawColor(border);
  doc.rect(leftX, topY, cardW, headerH); // border
  
  if (d1Image) {
    try {
      doc.addImage(d1Image, d1ImageFormat, leftX + 8, topY + 6, 22, 22);
    } catch (imgErr) {
      console.warn('Failed to add driver1 image to PDF, using fallback:', imgErr);
      // Fallback: colored circle with initials
      doc.setFillColor(d1Color);
      doc.circle(leftX + 19, topY + 17, 11, "F");
      const initials = driver1.fullName.split(' ').map(word => word[0]).join('').substring(0, 2);
      TXT(initials, leftX + 19, topY + 20, { size: 8, color: "#ffffff", bold: true, align: "center" });
    }
  } else {
    // Fallback: colored circle with initials
    doc.setFillColor(d1Color);
    doc.circle(leftX + 19, topY + 17, 11, "F");
    const initials = driver1.fullName.split(' ').map(word => word[0]).join('').substring(0, 2);
    TXT(initials, leftX + 19, topY + 20, { size: 8, color: "#ffffff", bold: true, align: "center" });
  }
  
  TXT(driver1.fullName, leftX + 36, topY + 16, { size: 14, bold: true });
  TXT(driver1.teamName, leftX + 36, topY + 26, { size: 10, color: subtle });
  // team underline
  rectF(leftX, topY + headerH - 3, cardW, 3, d1Color);

  // Right header
  rectF(rightX, topY, cardW, headerH, "#f8fafc");
  doc.rect(rightX, topY, cardW, headerH);
  
  if (d2Image) {
    try {
      doc.addImage(d2Image, d2ImageFormat, rightX + 8, topY + 6, 22, 22);
    } catch (imgErr) {
      console.warn('Failed to add driver2 image to PDF, using fallback:', imgErr);
      // Fallback: colored circle with initials
      doc.setFillColor(d2Color);
      doc.circle(rightX + 19, topY + 17, 11, "F");
      const initials = driver2.fullName.split(' ').map(word => word[0]).join('').substring(0, 2);
      TXT(initials, rightX + 19, topY + 20, { size: 8, color: "#ffffff", bold: true, align: "center" });
    }
  } else {
    // Fallback: colored circle with initials
    doc.setFillColor(d2Color);
    doc.circle(rightX + 19, topY + 17, 11, "F");
    const initials = driver2.fullName.split(' ').map(word => word[0]).join('').substring(0, 2);
    TXT(initials, rightX + 19, topY + 20, { size: 8, color: "#ffffff", bold: true, align: "center" });
  }
  
  TXT(driver2.fullName, rightX + 36, topY + 16, { size: 14, bold: true });
  TXT(driver2.teamName, rightX + 36, topY + 26, { size: 10, color: subtle });
  rectF(rightX, topY + headerH - 3, cardW, 3, d2Color);

  // Metrics block rendered manually (centered bars like reference image)
  const normalizeKey = (k: string) => {
    if (k === "dnf") return "dnfs";
    if (k === "fastest_laps") return "fastestLaps";
    if (k === "recent_form") return "recentForm";
    if (k === "sprint_wins") return "sprintWins";
    if (k === "sprint_podiums") return "sprintPodiums";
    return k;
  };

  const enabledRaw = Object.keys(enabledMetrics).filter((k) => enabledMetrics[k]);
  const enabled = Array.from(new Set(enabledRaw.map(normalizeKey)));

  const labelMap: Record<string, string> = {
    wins: "WINS",
    podiums: "PODIUMS",
    poles: "POLE POSITIONS",
    fastestLaps: "FASTEST LAPS",
    points: "POINTS",
    sprintWins: "SPRINT WINS",
    sprintPodiums: "SPRINT PODIUMS",
    dnfs: "DNF",
    races: "RACES",
    recentForm: "RECENT FORM",
  };

  const keyMap: Record<string, keyof DriverStats> = {
    wins: "wins",
    podiums: "podiums",
    poles: "poles",
    fastestLaps: "fastestLaps",
    points: "points",
    sprintWins: "sprintWins",
    sprintPodiums: "sprintPodiums",
    dnfs: "dnfs",
    races: "races",
    recentForm: "recentForm",
  };

  const contentMarginX = 22;
  const contentWidth = pageWidth - contentMarginX * 2;
  const centerX = pageWidth / 2;
  // Fit-to-one-page sizing based on available height
  const footerReserve = 24;          // space for footer
  const compositeReserve = 40;       // title + bar + labels
  const rowsCount = Math.max(enabled.length, 1);
  const available = pageHeight - footerReserve - compositeReserve - currentY;
  const baseRowH = 22;               // approx height per row before scaling
  const scale = Math.min(1, available / (rowsCount * baseRowH));
  const rowGap = Math.max(8, Math.round(14 * scale));
  const barH = Math.max(6, Math.round(10 * scale));
  const barW = Math.min(230, contentWidth * 0.75);
  const valueFontSize = Math.max(12, Math.round(16 * scale));
  const labelFontSize = Math.max(9, Math.round(10 * scale));

  enabled.forEach((metric) => {
    const k = keyMap[metric];
    // Skip if metric key is not found in keyMap
    if (!k) {
      console.warn(`PDF export: Unknown metric '${metric}' - skipping`);
      return;
    }
    
    const label = (labelMap[metric] || metric).toUpperCase();
    // Ensure values are valid numbers
    let v1 = (stats1 as any)[k] ?? 0;
    let v2 = (stats2 as any)[k] ?? 0;
    
    // Convert strings to numbers if needed
    if (typeof v1 === 'string') {
      v1 = parseFloat(v1);
    }
    if (typeof v2 === 'string') {
      v2 = parseFloat(v2);
    }
    
    // Convert to numbers and handle NaN/Infinity
    v1 = typeof v1 === 'number' && isFinite(v1) ? v1 : 0;
    v2 = typeof v2 === 'number' && isFinite(v2) ? v2 : 0;

    ensureSpace(28);
    // label centered above bar
    TXT(label, centerX, currentY, { size: labelFontSize, color: subtle, align: "center", bold: true });
    currentY += 5;

    // numbers and bar
    doc.setFontSize(valueFontSize);
    doc.setTextColor(text);
    const barX = centerX - barW / 2;
    const barY = currentY;

    // values
    doc.text(formatNumber(v1), barX - 6, barY + barH - 1, { align: "right" });
    doc.text(formatNumber(v2), barX + barW + 6, barY + barH - 1, { align: "left" });

    // background strip
    doc.setFillColor(24, 24, 27);
    doc.rect(barX, barY, barW, barH, "F");

    // For metrics where lower is better (DNFs, recent form), invert the proportions
    const isLowerBetter = metric === 'dnfs' || metric === 'recentForm';
    
    let leftW: number;
    let rightW: number;
    
    if (isLowerBetter && v1 > 0 && v2 > 0) {
      // Invert: the driver with the lower value should have the larger bar
      // Convert values to inverted proportions (higher value = smaller bar)
      const inv1 = 1 / v1;
      const inv2 = 1 / v2;
      const totalInv = inv1 + inv2;
      leftW = (inv1 / totalInv) * barW;
      rightW = barW - leftW;
    } else {
      // Normal calculation: higher value = larger bar
      const total = Math.max(v1 + v2, 1);
      leftW = (v1 / total) * barW;
      rightW = barW - leftW;
    }
    
    // Ensure widths are valid and non-negative
    leftW = Math.max(0, Math.min(leftW, barW));
    rightW = Math.max(0, Math.min(rightW, barW));
    
    const [r1, g1, b1] = hexToRgb(d1Color);
    const [r2, g2, b2] = hexToRgb(d2Color);
    
    // Only draw rectangles if they have valid dimensions
    if (leftW > 0) {
      doc.setFillColor(r1, g1, b1);
      doc.rect(barX, barY, leftW, barH, "F");
    }
    if (rightW > 0) {
      doc.setFillColor(r2, g2, b2);
      doc.rect(barX + leftW, barY, rightW, barH, "F");
    }

    // divider - only draw if we have both sections
    if (leftW > 0 && leftW < barW) {
      doc.setDrawColor(60, 60, 70);
      doc.setLineWidth(0.3);
      doc.line(barX + leftW, barY, barX + leftW, barY + barH);
    }

    // separator line under row
    const sepY = barY + barH + 6;
    doc.setDrawColor(40, 40, 46);
    doc.setLineWidth(0.2);
    doc.line(contentMarginX, sepY, pageWidth - contentMarginX, sepY);

    currentY = sepY + rowGap - 6;
  });

  function hexToRgb(hex: string) {
    const m = hex.replace("#", "");
    return [parseInt(m.slice(0,2),16), parseInt(m.slice(2,4),16), parseInt(m.slice(4,6),16)];
  }


  // Centered composite score section
  const compositeTitle = "Composite Score";
  const center = pageWidth / 2;
  const maxBarW = Math.min(220, pageWidth - marginX * 2 - 20);
  const scoreBarW = maxBarW;
  const scoreBarH = 10;
  const scoreTop = currentY + 10;
  // Compute composite score if not provided: average normalized share across enabled metrics
  const computeComposite = () => {
    let s1 = 0;
    let s2 = 0;
    let n = 0;
    enabled.forEach((metric) => {
      const k = keyMap[metric];
      const v1 = (stats1 as any)[k] ?? 0;
      const v2 = (stats2 as any)[k] ?? 0;
      const t = v1 + v2;
      if (t > 0) {
        s1 += v1 / t;
        s2 += v2 / t;
        n += 1;
      }
    });
    if (n === 0) return { a: 0, b: 0 };
    const a = Math.round((s1 / n) * 100);
    const b = Math.max(0, 100 - a);
    return { a, b };
  };
  const provided = score.d1 != null && score.d2 != null;
  const derived = provided ? { a: score.d1 as number, b: score.d2 as number } : computeComposite();

  ensureSpace(40);
  // Title centered
  TXT(compositeTitle, center, scoreTop, { size: 13, bold: true, align: "center" });

  // Bar centered
  const barX = center - scoreBarW / 2;
  const barY = scoreTop + 6;

  // background
  doc.setFillColor(241, 245, 249);
  doc.rect(barX, barY, scoreBarW, scoreBarH, "F");

  if (true) {
    const total = Math.max(derived.a + derived.b, 1);
    const d1W = (derived.a / total) * scoreBarW;
    const d2W = scoreBarW - d1W;

    // fills
    const [r1, g1, b1] = hexToRgb(d1Color);
    const [r2, g2, b2] = hexToRgb(d2Color);
    doc.setFillColor(r1, g1, b1);
    doc.rect(barX, barY, d1W, scoreBarH, "F");
    doc.setFillColor(r2, g2, b2);
    doc.rect(barX + d1W, barY, d2W, scoreBarH, "F");

    // outline
    doc.setDrawColor(border);
    doc.rect(barX, barY, scoreBarW, scoreBarH);

    // End labels below the bar ends
    const labelsY = barY + 16;
    TXT(`${driver1.fullName}: ${derived.a}`, barX, labelsY, { size: 10, color: subtle, align: "left" });
    TXT(`${driver2.fullName}: ${derived.b}`, barX + scoreBarW, labelsY, { size: 10, color: subtle, align: "right" });

    // Centered winner ribbon
    const winner = derived.a > derived.b ? driver1 : driver2;
    const wColor = derived.a > derived.b ? d1Color : d2Color;
    const ribbonW = 70;
    const ribbonH = 16;
    const ribbonX = center - ribbonW / 2;
    const ribbonY = labelsY + 6;

    // ribbon
    doc.setFillColor(245, 245, 245);
    doc.setDrawColor(border);
    doc.roundedRect(ribbonX, ribbonY, ribbonW, ribbonH, 2, 2, "FD");

    // top stripe
    const [wr, wg, wb] = hexToRgb(wColor);
    doc.setFillColor(wr, wg, wb);
    doc.rect(ribbonX, ribbonY, ribbonW, 3, "F");

    TXT(`WINNER: ${winner.fullName}`, center, ribbonY + 11, { size: 9, bold: true, align: "center" });
  }

  // Centered footer
  drawFooter();

  const fileName = `driver-comparison-${driver1.fullName.replace(/\s+/g, "-")}-vs-${driver2.fullName.replace(/\s+/g, "-")}.pdf`;
  doc.save(fileName);
};