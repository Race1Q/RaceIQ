// frontend/src/components/compare/DriverPdfComparisonCard.tsx
import jsPDF from "jspdf";
import { getTeamColor } from "../../lib/teamColors";
import { getTeamLogo } from "../../lib/teamAssets";
import { loadImageAsDataURL } from "../../lib/pdfUtils";

interface DriverPdfData {
  id: string;
  fullName: string;
  teamName: string;
  championshipStanding: number | string | null;
  wins: number;
  podiums: number;
  points: number;
  imageUrl: string;
  teamColorToken: string;
  teamColorHex?: string;
}

interface DriverStats {
  wins: number;
  podiums: number;
  fastestLaps: number;
  points: number;
  dnfs: number;
  sprintWins: number;
  sprintPodiums: number;
}

interface DriverComparisonData {
  driver1: DriverPdfData;
  driver2: DriverPdfData;
  stats1: DriverStats;
  stats2: DriverStats;
  enabledMetrics: Record<string, boolean>;
  score: {
    d1: number | null;
    d2: number | null;
  };
}

export const DriverPdfComparisonCard = async (data: DriverComparisonData) => {
  const { driver1, driver2, stats1, stats2, enabledMetrics, score } = data;
  
  // Determine orientation based on number of selected metrics
  const enabledCountForLayout = Object.keys(enabledMetrics).filter((k) => (enabledMetrics as any)[k]).length;
  const usePortrait = enabledCountForLayout > 4; // switch to portrait when many rows
  const doc = new jsPDF(usePortrait ? "portrait" : "landscape", "mm", "a4");
  const pageWidth = doc.internal.pageSize.getWidth();
  const pageHeight = doc.internal.pageSize.getHeight();
  
  // Colors & theme
  const text = "#111827";
  const subtle = "#6b7280";
  const border = "#e5e7eb";
  const railW = 6;

  const d1Color = driver1.teamColorHex || getTeamColor(driver1.teamName) || "#0ea5e9";
  const d2Color = driver2.teamColorHex || getTeamColor(driver2.teamName) || "#ef4444";

  // Safe text helper (no unsupported glyphs)
  const TXT = (t: string, x: number, y: number, opts: { size?: number; color?: string; align?: "left" | "center" | "right"; bold?: boolean } = {}) => {
    const { size = 11, color = text, align = "left", bold = false } = opts;
    doc.setTextColor(color);
    doc.setFont("helvetica", bold ? "bold" : "normal");
    doc.setFontSize(size);
    const xPos = align === "center" ? x : align === "right" ? x : x;
    doc.text(t, xPos, y, { align });
  };

  const rectF = (x: number, y: number, w: number, h: number, fill: string) => {
    doc.setFillColor(fill);
    doc.rect(x, y, w, h, "F");
  };

  const drawRails = () => {
    rectF(0, 26, railW, pageHeight - 26, d1Color);
    rectF(pageWidth - railW, 26, railW, pageHeight - 26, d2Color);
  };

  const drawFooter = () => {
    const footY = pageHeight - 10;
    const footText = "Generated by RaceIQ â€¢ raceiq.com";
    doc.setDrawColor(border);
    doc.line(marginX, footY - 6, pageWidth - marginX, footY - 6);
    TXT(footText, pageWidth / 2, footY, { size: 9, color: subtle, align: "center" });
  };

  const ensureSpace = (_needed: number) => {
    // Single-page export: scaling ensures we fit, so this becomes a no-op
    return;
  };

  // Header band
  rectF(0, 0, pageWidth, 26, "#0f172a");
  TXT("Driver Comparison", 10, 16, { size: 16, color: "#ffffff", bold: true });
  TXT("RaceIQ Analytics", pageWidth - 70, 12, { size: 10, color: "#cbd5e1", align: "left" });
  TXT(new Date().toLocaleDateString(), pageWidth - 70, 19, { size: 10, color: "#cbd5e1", align: "left" });

  // Side rails (team accents)
  drawRails();

  // Card layout
  const marginX = 16;
  const topY = 34;
  const cardW = (pageWidth - marginX * 2 - 20) / 2;
  const gap = 20;

  // Load team logos (PNG data URLs)
  const d1LogoUrl = getTeamLogo(driver1.teamName);
  const d2LogoUrl = getTeamLogo(driver2.teamName);
  
  let d1Logo = null;
  let d2Logo = null;
  
  if (d1LogoUrl) {
    const logoData = await loadImageAsDataURL(d1LogoUrl);
    d1Logo = logoData || null;
  }
  
  if (d2LogoUrl) {
    const logoData = await loadImageAsDataURL(d2LogoUrl);
    d2Logo = logoData || null;
  }

  // Driver cards: headers
  const leftX = marginX;
  const rightX = marginX + cardW + gap;

  const headerH = 34;

  // Left header
  rectF(leftX, topY, cardW, headerH, "#f8fafc");
  doc.setDrawColor(border);
  doc.rect(leftX, topY, cardW, headerH); // border
  
  if (d1Logo) {
    doc.addImage(d1Logo, "PNG", leftX + 8, topY + 6, 22, 22);
  } else {
    // Fallback: colored circle with initials
    doc.setFillColor(d1Color);
    doc.circle(leftX + 19, topY + 17, 11, "F");
    const initials = driver1.teamName.split(' ').map(word => word[0]).join('').substring(0, 2);
    TXT(initials, leftX + 19, topY + 20, { size: 8, color: "#ffffff", bold: true, align: "center" });
  }
  
  TXT(driver1.fullName, leftX + 36, topY + 16, { size: 14, bold: true });
  TXT(driver1.teamName, leftX + 36, topY + 26, { size: 10, color: subtle });
  // team underline
  rectF(leftX, topY + headerH - 3, cardW, 3, d1Color);

  // Right header
  rectF(rightX, topY, cardW, headerH, "#f8fafc");
  doc.rect(rightX, topY, cardW, headerH);
  
  if (d2Logo) {
    doc.addImage(d2Logo, "PNG", rightX + 8, topY + 6, 22, 22);
  } else {
    // Fallback: colored circle with initials
    doc.setFillColor(d2Color);
    doc.circle(rightX + 19, topY + 17, 11, "F");
    const initials = driver2.teamName.split(' ').map(word => word[0]).join('').substring(0, 2);
    TXT(initials, rightX + 19, topY + 20, { size: 8, color: "#ffffff", bold: true, align: "center" });
  }
  
  TXT(driver2.fullName, rightX + 36, topY + 16, { size: 14, bold: true });
  TXT(driver2.teamName, rightX + 36, topY + 26, { size: 10, color: subtle });
  rectF(rightX, topY + headerH - 3, cardW, 3, d2Color);

  // Metrics block rendered manually (centered bars like reference image)
  const normalizeKey = (k: string) => {
    if (k === "dnf") return "dnfs";
    if (k === "fastest_laps") return "fastestLaps";
    return k;
  };

  const enabledRaw = Object.keys(enabledMetrics).filter((k) => enabledMetrics[k]);
  const enabled = Array.from(new Set(enabledRaw.map(normalizeKey)));

  const labelMap: Record<string, string> = {
    wins: "QUALIFYING",
    podiums: "RACE",
    poles: "POLE POSITIONS",
    fastestLaps: "FASTEST LAPS",
    points: "POINTS",
    sprintWins: "SPRINT WINS",
    sprintPodiums: "SPRINT PODIUMS",
    dnfs: "DNF",
  };

  const keyMap: Record<string, keyof DriverStats> = {
    wins: "wins",
    podiums: "podiums",
    poles: "poles",
    fastestLaps: "fastestLaps",
    points: "points",
    sprintWins: "sprintWins",
    sprintPodiums: "sprintPodiums",
    dnfs: "dnfs",
  };

  const contentMarginX = 22;
  const contentWidth = pageWidth - contentMarginX * 2;
  const centerX = pageWidth / 2;
  // Fit-to-one-page sizing based on available height
  const footerReserve = 24;          // space for footer
  const compositeReserve = 40;       // title + bar + labels
  const startY = topY + headerH + 10;
  const rowsCount = Math.max(enabled.length, 1);
  const available = pageHeight - footerReserve - compositeReserve - startY;
  const baseRowH = 22;               // approx height per row before scaling
  const scale = Math.min(1, available / (rowsCount * baseRowH));
  const rowGap = Math.max(8, Math.round(14 * scale));
  const barH = Math.max(6, Math.round(10 * scale));
  const barW = Math.min(230, contentWidth * 0.75);
  const valueFontSize = Math.max(12, Math.round(16 * scale));
  const labelFontSize = Math.max(9, Math.round(10 * scale));
  let y = startY;

  enabled.forEach((metric) => {
    const k = keyMap[metric];
    const label = (labelMap[metric] || metric).toUpperCase();
    const v1 = (stats1 as any)[k] ?? 0;
    const v2 = (stats2 as any)[k] ?? 0;

    ensureSpace(28);
    // label centered above bar
    TXT(label, centerX, y, { size: labelFontSize, color: subtle, align: "center", bold: true });
    y += 5;

    // numbers and bar
    doc.setFontSize(valueFontSize);
    doc.setTextColor(text);
    const barX = centerX - barW / 2;
    const barY = y;

    // values
    doc.text(String(v1), barX - 6, barY + barH - 1, { align: "right" });
    doc.text(String(v2), barX + barW + 6, barY + barH - 1, { align: "left" });

    // background strip
    doc.setFillColor(24, 24, 27);
    doc.rect(barX, barY, barW, barH, "F");

    const total = Math.max(v1 + v2, 1);
    const leftW = (v1 / total) * barW;
    const [r1, g1, b1] = hexToRgb(d1Color);
    const [r2, g2, b2] = hexToRgb(d2Color);
    doc.setFillColor(r1, g1, b1);
    doc.rect(barX, barY, leftW, barH, "F");
    doc.setFillColor(r2, g2, b2);
    doc.rect(barX + leftW, barY, barW - leftW, barH, "F");

    // divider
    doc.setDrawColor(60, 60, 70);
    doc.setLineWidth(0.3);
    doc.line(barX + leftW, barY, barX + leftW, barY + barH);

    // separator line under row
    const sepY = barY + barH + 6;
    doc.setDrawColor(40, 40, 46);
    doc.setLineWidth(0.2);
    doc.line(contentMarginX, sepY, pageWidth - contentMarginX, sepY);

    y = sepY + rowGap - 6;
  });

  function hexToRgb(hex: string) {
    const m = hex.replace("#", "");
    return [parseInt(m.slice(0,2),16), parseInt(m.slice(2,4),16), parseInt(m.slice(4,6),16)];
  }


  // Centered composite score section
  const compositeTitle = "Composite Score";
  const center = pageWidth / 2;
  const maxBarW = Math.min(220, pageWidth - marginX * 2 - 20);
  const scoreBarW = maxBarW;
  const scoreBarH = 10;
  const scoreTop = y + 10;
  // Compute composite score if not provided: average normalized share across enabled metrics
  const computeComposite = () => {
    let s1 = 0;
    let s2 = 0;
    let n = 0;
    enabled.forEach((metric) => {
      const k = keyMap[metric];
      const v1 = (stats1 as any)[k] ?? 0;
      const v2 = (stats2 as any)[k] ?? 0;
      const t = v1 + v2;
      if (t > 0) {
        s1 += v1 / t;
        s2 += v2 / t;
        n += 1;
      }
    });
    if (n === 0) return { a: 0, b: 0 };
    const a = Math.round((s1 / n) * 100);
    const b = Math.max(0, 100 - a);
    return { a, b };
  };
  const provided = score.d1 != null && score.d2 != null;
  const derived = provided ? { a: score.d1 as number, b: score.d2 as number } : computeComposite();

  ensureSpace(40);
  // Title centered
  TXT(compositeTitle, center, scoreTop, { size: 13, bold: true, align: "center" });

  // Bar centered
  const barX = center - scoreBarW / 2;
  const barY = scoreTop + 6;

  // background
  doc.setFillColor(241, 245, 249);
  doc.rect(barX, barY, scoreBarW, scoreBarH, "F");

  if (true) {
    const total = Math.max(derived.a + derived.b, 1);
    const d1W = (derived.a / total) * scoreBarW;
    const d2W = scoreBarW - d1W;

    // fills
    const [r1, g1, b1] = hexToRgb(d1Color);
    const [r2, g2, b2] = hexToRgb(d2Color);
    doc.setFillColor(r1, g1, b1);
    doc.rect(barX, barY, d1W, scoreBarH, "F");
    doc.setFillColor(r2, g2, b2);
    doc.rect(barX + d1W, barY, d2W, scoreBarH, "F");

    // outline
    doc.setDrawColor(border);
    doc.rect(barX, barY, scoreBarW, scoreBarH);

    // End labels below the bar ends
    const labelsY = barY + 16;
    TXT(`${driver1.fullName}: ${derived.a}`, barX, labelsY, { size: 10, color: subtle, align: "left" });
    TXT(`${driver2.fullName}: ${derived.b}`, barX + scoreBarW, labelsY, { size: 10, color: subtle, align: "right" });

    // Centered winner ribbon
    const winner = derived.a > derived.b ? driver1 : driver2;
    const wColor = derived.a > derived.b ? d1Color : d2Color;
    const ribbonW = 70;
    const ribbonH = 16;
    const ribbonX = center - ribbonW / 2;
    const ribbonY = labelsY + 6;

    // ribbon
    doc.setFillColor(245, 245, 245);
    doc.setDrawColor(border);
    doc.roundedRect(ribbonX, ribbonY, ribbonW, ribbonH, 2, 2, "FD");

    // top stripe
    const [wr, wg, wb] = hexToRgb(wColor);
    doc.setFillColor(wr, wg, wb);
    doc.rect(ribbonX, ribbonY, ribbonW, 3, "F");

    TXT(`WINNER: ${winner.fullName}`, center, ribbonY + 11, { size: 9, bold: true, align: "center" });
  }

  // Centered footer
  drawFooter();

  const fileName = `driver-comparison-${driver1.fullName.replace(/\s+/g, "-")}-vs-${driver2.fullName.replace(/\s+/g, "-")}.pdf`;
  doc.save(fileName);
};